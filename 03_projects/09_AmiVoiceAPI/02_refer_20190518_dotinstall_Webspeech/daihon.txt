# JavaScriptで音声認識サービスを作ろう (全5回)
- Refer: (https://dotinstall.com/lessons/webspeech_js)
- 作成サイト: (02_work/index.html)

------------------------------------------------------------
## 01 開発の準備を整えよう (02:45)
- 完成版の確認
- index.htmlの作成
```
　　0:00	このレッスンでは JavaScript の応用編として、 Chrome ブラウザを使った音声認識サービスの作り方について学んでいきましょう。
　　0:10	いろいろなことができるのですが、今回は色の名前を英語でしゃべると背景色が変わる、といったものを作ってみたいと思います。
　　0:17	では Start を押して確認していきます。
　　0:20	「Pink」「Orange」…こうですね、うまくいっています。
　　0:28	シンプルなのですが仕組みがわかるといろいろと応用が利くので、今から詳しく見ていきたいと思います。
　　0:35	それから、今回使う命令はまだ実験的なもので、基本的に Chrome ブラウザでしか動かないので、まだ用意していない人は Chrome を用意しておいてください。
　　0:44	それから今回のアプリですが、サーバー環境だと快適に動作するので、今回は macOS にあらかじめ入っている PHP のビルドインサーバーを使っていきます。
　　0:55	Windows の方はローカル開発環境などで動かしてみてください。
　　0:58	それから、このあたりは少し知識が必要なので、よくわからなかった人はまずは動画を見るだけにして、あとで詳しく調べてみるのもいいかと思います。
　　1:08	ではさっそくですが、ひな形となるファイルを作っていきましょう。
　　1:12	HTML ファイルに書いていきたいと思います。
　　1:15	では右下から HTML モードにしてあげて、 HTML5 の書き方でどんどん書いていきましょう。
　　1:31	head 要素の中に文字コードの設定と、 title タグを入れておきたいと思います。
　　1:42	今回適当に Web Speech としてあげましょう。
　　1:46	それから body の中ですが、 button を作っておきたいのと、 script タグを入れておきたいですね。
　　2:00	script タグの中身ですが、とりあえず 'use strict' で厳密なエラーチェックをするようにしつつ、変数の scope を限定したいのでブロックを作っておきましょう。
　　2:11	では保存していきます。
　　2:13	macOS だったら Command + S でいいですね。
　　2:17	今回はデスクトップに WebSpeech というフォルダを作ってあげて、その中に index.html という名前で保存してあげましょう。
　　2:30	これでいいですね。
　　2:32	ツリービューが出てきましたが、要らないので閉じておいてあげます。
　　2:36	では続きは次回にしていきましょう。
```

------------------------------------------------------------
## 02 サーバー環境で動作を確認しよう (02:24)
- ボタン、イベントリスナーの設置
- 動作確認
```
　　0:00	さて、次はローカルサーバーを立てて、前回作った index.html をブラウザで表示していきましょう。
　　0:09	では、ターミナルを開くとこういった画面になっているかと思うので、デスクトップの WebSpeech フォルダまで移動してあげましょう。
　　0:16	cd Desktop としたあとに cd WebSpeech としてあげれば OK ですね。
　　0:22	今回は PHP のビルドイン Web サーバーを使ってあげましょう。
　　0:26	php -S で、どの IP （アドレス）からも通信を受け付けたいので 0.0.0.0: としつつ、今回ポート番号は 8080 番にしてあげましょう。
　　0:41	こうですね、うまく立ち上がったようなのでブラウザのほうで確認していきます。
　　0:46	では localhost:8080 としてあげましょう。
　　0:51	こうですね、ボタンが表示されたのでうまくいったようです。
　　0:55	では続けて、ボタンをクリックしたときの処理を書けるようにしておきましょう。
　　1:00	まずはボタン要素を取得したいので、定数を設定しておきましょう。
　　1:07	では const btn としてあげて、今回は document.querySelector を使ってあげましょう。
　　1:15	… ('button'); のようにすれば、こちらの要素を取得することができますね。
　　1:20	ではその上で、 btn に対して .addEventListener としてあげます。
　　1:27	クリックしたときに次の処理をしなさいよ、と書いてあげれば OK ですね。
　　1:34	とりあえず動作確認がしたいので、 console.log で button clicked! というメッセージを出してみましょう。
　　1:44	ではいったん保存してあげて、ブラウザのほうでコンソールを出していきたいのですが、 macOS だったらショートカットキーが Command + Option + J ですね。
　　1:57	下だと少し見にくいので、こちらから右に配置するようにしてあげましょう。
　　2:03	こうですね、右側を広くとっておきました。
　　2:07	ではリロードしてあげて、クリックしてみましょう。
　　2:10	こうですね、ちゃんとメッセージが出たので OK かと思います。
　　2:14	ではここまでうまくいったので、続きは次回にしていきましょう。
```


------------------------------------------------------------
## 03 音声を認識させてみよう (02:41)
- webkitSpeechRecognitionオブジェクトの設定
- 音声認識の実装
- 処理結果の見方
```
　　0:00	さて、では音声認識サービスを作っていきましょう。
　　0:06	まずは音声認識サービスのためのオブジェクトを取得していきます。
　　0:11	では speech という名前にしてあげて、 new webkitSpeechRecognition(); としてあげれば OK です。
　　0:21	それから言語設定をしておきましょう。
　　0:23	最終的には英語を認識させるのですが、まずはテストで日本語を認識させたいので、 speech.lang = 'ja-JP'; としてあげれば OK です。
　　0:34	では、ボタンをクリックしたら音声認識を開始してあげましょう。
　　0:38	いったん console.log の行は Command + / でコメントにしておいてあげつつ、 speech.start(); としておいてあげます。
　　0:47	ボタンを二度押しすると 2 回スタートしてしまうので、それを避けるために btn.disabled = true; としておくと親切かと思います。
　　0:58	では次に、認識したテキストをとりあえずコンソールに表示してみましょう。
　　1:03	どうするかというと、こちらのオブジェクトには onresult というイベントが用意されていて、なんらかの言葉が認識されたときの処理を書いていくことができます。
　　1:14	では、とりあえずいろいろな情報は e という引数で受けつつ処理を書いていきましょう。
　　1:21	とりあえず console.log(e); としてあげれば OK かと思います。
　　1:30	そのあとに音声認識を止めたいので speech.stop(); としてあげましょう。
　　1:36	ではいったん保存してあげて、ブラウザのほうで見てあげます。
　　1:40	リロードをかけてあげて Start を押していきましょう。
　　1:43	そうすると許可を求められるので「許可」をクリックしたあとに、「こんにちは」としゃべってみましょう。
　　1:50	「こんにちは」…こうですね、なにやら出たので見てあげましょう。
　　1:58	大事なのは、こちらの下のほうにある results という項目ですね
　　2:04	results の 0 番目の中にいろいろなものが入っているのですが、まず isFinal というのは処理が終わったことを示すフラグなので、覚えておいてください。
　　2:16	処理が終わったら isFinal は true になりますね。
　　2:19	さらにこちらを展開すると、その中に transcript という項目があって、こちらが認識結果になります。
　　2:28	あとはこの認識結果を使ってあげれば OK なので、いろいろやっていきたいのですが、続きは次回にしていきましょう。
```


------------------------------------------------------------
## 04 背景色を変えてみよう (02:13)
- 背景色の変更
- 動作確認
```
　　0:00	さて、次はこの結果を使っていきたいのですが、今回は英語を認識して背景色を変えていきたいので、こちらをいったん英語設定にしてあげましょう。
　　0:14	speech.lang = 'en-US'; としてあげれば OK です。
　　0:17	次にこちらの処理ですね。
　　0:19	console.log(e); の行はいったん Command + / でコメントにしておいてあげます。
　　0:25	ではいったん認識を stop したあとに結果を使って判断していきたいので、まず isFinal が true かどうかで処理をしてあげましょう。
　　0:36	isFinal は、 results の中の 0 番目の isFinal なので、そのように書いてあげれば OK でしょう。
　　0:43	e.results[0].isFinal が true だった場合は次の処理をしなさい、と書いていってあげます。
　　0:52	まずは認識結果を表示しておきましょう。
　　0:57	認識結果ですが、 e の results の 0 番目の 0 番目の transcript なので、そのように書いていけばいいでしょう。
　　1:06	では e.results[0][0].transcript としてあげましょう。
　　1:14	その上で、背景色にしてあげればいいので document.body.style.background を、この認識した値にしてあげれば OK かと思います。
　　1:29	ではこれで OK かと思うので、保存してあげてブラウザをリロードして確かめていきましょう。
　　1:35	では Start としてあげて、「Pink」と言ってみます。
　　1:39	「Pink」…こうですね、ちゃんと Pink が認識されて背景色が変わったののがわかるかと思います。
　　1:47	なお、認識した値が CSS に対応していない場合は、単に命令が無効になって色が変わらないのですが、今回はその仕様で良しとしましょう。
　　1:59	それから、できれば連続で認識してくれると使いやすいと思うのですが、そのあたりを次回やっていきましょう。
```


------------------------------------------------------------
## 05 アプリを完成させよう (02:10)
- onendイベントの実装
- onsoundstart、onsoundendイベントの実装
```
　　0:00	さて、基本的なところはできたのですが、連続で認識してくれるようにしていきましょう。
　　0:08	どうするかというと、 stop が呼ばれたときに onend というイベントが設定されているのでそちらを使ってあげます。
　　0:15	では speech.onend としてあげて、どういう処理をするかをこちらに書いていきましょう。
　　0:24	とはいっても簡単で speech.start(); としてあげれば、連続で認識してくれるはずです。
　　0:31	では保存してあげて、ブラウザのほうで確認していきましょう。
　　0:34	ではリロードしてあげて、確かめていきます。
　　0:38	「Pink」「Gray」「Orange」…こうですね、うまくいっているのがわかるかと思います。
　　0:50	それから、音声の認識が始まったときと終わったときでボタンのラベルが変わるとわかりやすいかと思います。
　　0:58	そのあたりもやっておきましょう。
　　1:00	どうするかというと、それぞれ speech.onsoundstart と speech.onsoundend というイベントが用意されているので、書いていってあげましょう。
　　1:13	ボタンのテキストを変えたいので btn.textContent を speech.onsoundstart の場合は 'Processing...'; と変えてあげましょう。
　　1:27	そして speech.onsoundend のときは 'Waiting...'; としておきたいと思います。
　　1:37	では保存して、ブラウザのほうでリロードして確かめていきましょう。
　　1:43	「Pink」…こうですね、ちゃんと変わっているので OK かと思います。
　　1:50	今回は、ざっと基本的なところを見てきました。
　　1:54	現在のところ Chrome ブラウザにしか対応していないので使いどころが限られますが、アイデア次第でいろいろなアプリが作れるかと思うので、作例の一つとして参考にしてみてください。
```


------------------------------------------------------------
